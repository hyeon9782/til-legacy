function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}
// 렌더링하는 동안 '방금' 생성한 변수와 객체를 변경하는 것은 괜찮습니다.
// cups 변수나 [] 배열이 TeaGathering 함수 외부에서 생성되었다면 큰 문제가 될 것입니다.
// 해당 배열에 항목을 밀어 넣음으로써 기존 객체를 변경하게 될 것이기 때문입니다.
// 하지만 TeaGathering 내부에서 동일한 렌더링 중에 생성했기 때문에 괜찮습니다.

export default function TeaGathering() {
  let cups = [];
  for (let i = 1; i <= 12; i++) {
    cups.push(<Cup key={i} guest={i} />);
  }
  return cups;
}

// React는 왜 순수성을 유지해야할까?
// 1. 컴포넌트를 다른 환경(예: 서버)에서 실행할 수 있습니다! 동일한 입력에 대해 동일한 결과를 반환하기 때문에 하나의 컴포넌트가 많은 사용자 요청을 처리할 수 있습니다.
// 2. 입력이 변경되지 않은 컴포넌트는 렌더링 건너뛰기를 통해 성능을 향상시킬 수 있습니다. 순수 함수는 항상 동일한 결과를 반환하므로 캐싱해도 안전합니다.
// 3. 깊은 컴포넌트 트리를 렌더링하는 도중에 일부 데이터가 변경되면 React는 오래된 렌더링을 완료하기 위해 시간을 낭비하지 않고 렌더링을 다시 시작할 수 있습니다. 순수성 덕분에 언제든지 계산을 중단해도 안전합니다.

// 1. 컴포넌트는 순수해야합니다.
// - **자신의 일에만 신경씁니다.** 렌더링 전에 존재했던 객체나 변수를 변경하지 않아야 합니다.
// - **동일한 입력, 동일한 출력.** 동일한 입력이 주어지면 컴포넌트는 항상 동일한 JSX를 반환해야 합니다.
// 2. 렌더링은 언제든지 발생할 수 있으므로, 컴포넌트는 서로의 렌더링 순서에 의존해서는 안 됩니다.
// 3. 컴포넌트가 렌더링에 사용하는 어떠한 입력값도 변이해서는 안 됩니다.
// 여기에는 props, state 및 context가 포함됩니다. 화면을 업데이트하려면 기존 객체를 변이하는 대신 "set" state를 사용하세요.
// 4. 컴포넌트의 로직을 반환하는 JSX 안에 표현하기 위해 노력하세요.
// "무언가를 변경"해야 할 때는 보통 이벤트 핸들러에서 이 작업을 수행하고자 할 것입니다. 최후의 수단으로 useEffect를 사용할 수도 있습니다.
// 5. 순수 함수를 작성하는 데는 약간의 연습이 필요하지만, React 패러다임의 힘을 발휘할 수 있습니다.